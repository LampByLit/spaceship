import "./chunk-BUSYA2B4.js";

// node_modules/zzfx/ZzFX.js
function zzfx(...parameters) {
  return ZZFX.play(...parameters);
}
var ZZFX = {
  // master volume scale
  volume: 0.3,
  // sample rate for audio
  sampleRate: 44100,
  // create shared audio context
  audioContext: new AudioContext(),
  // play a sound from zzfx paramerters
  play: function(...parameters) {
    return this.playSamples([this.buildSamples(...parameters)]);
  },
  // play an array of samples
  playSamples: function(sampleChannels, volumeScale = 1, rate = 1, pan = 0, loop = false) {
    const channelCount = sampleChannels.length;
    const sampleLength = sampleChannels[0].length;
    const buffer = this.audioContext.createBuffer(channelCount, sampleLength, this.sampleRate);
    const source = this.audioContext.createBufferSource();
    sampleChannels.forEach((c, i) => buffer.getChannelData(i).set(c));
    source.buffer = buffer;
    source.playbackRate.value = rate;
    source.loop = loop;
    const gainNode = this.audioContext.createGain();
    gainNode.gain.value = this.volume * volumeScale;
    gainNode.connect(this.audioContext.destination);
    const pannerNode = new StereoPannerNode(this.audioContext, { "pan": pan });
    source.connect(pannerNode).connect(gainNode);
    source.start();
    return source;
  },
  // build an array of samples
  buildSamples: function(volume = 1, randomness = 0.05, frequency = 220, attack = 0, sustain = 0, release = 0.1, shape = 0, shapeCurve = 1, slide = 0, deltaSlide = 0, pitchJump = 0, pitchJumpTime = 0, repeatTime = 0, noise = 0, modulation = 0, bitCrush = 0, delay = 0, sustainVolume = 1, decay = 0, tremolo = 0, filter = 0) {
    let sampleRate = this.sampleRate, PI2 = Math.PI * 2, abs = Math.abs, sign = (v) => v < 0 ? -1 : 1, startSlide = slide *= 500 * PI2 / sampleRate / sampleRate, startFrequency = frequency *= (1 + randomness * 2 * Math.random() - randomness) * PI2 / sampleRate, modOffset = 0, repeat = 0, crush = 0, jump = 1, length, b = [], t = 0, i = 0, s = 0, f, quality = 2, w = PI2 * abs(filter) * 2 / sampleRate, cos = Math.cos(w), alpha = Math.sin(w) / 2 / quality, a0 = 1 + alpha, a1 = -2 * cos / a0, a2 = (1 - alpha) / a0, b0 = (1 + sign(filter) * cos) / 2 / a0, b1 = -(sign(filter) + cos) / a0, b2 = b0, x2 = 0, x1 = 0, y2 = 0, y1 = 0;
    const minAttack = 9;
    attack = attack * sampleRate || minAttack;
    decay *= sampleRate;
    sustain *= sampleRate;
    release *= sampleRate;
    delay *= sampleRate;
    deltaSlide *= 500 * PI2 / sampleRate ** 3;
    modulation *= PI2 / sampleRate;
    pitchJump *= PI2 / sampleRate;
    pitchJumpTime *= sampleRate;
    repeatTime = repeatTime * sampleRate | 0;
    volume *= this.volume;
    for (length = attack + decay + sustain + release + delay | 0; i < length; b[i++] = s * volume) {
      if (!(++crush % (bitCrush * 100 | 0))) {
        s = shape ? shape > 1 ? shape > 2 ? shape > 3 ? shape > 4 ? (
          // wave shape
          (t / PI2 % 1 < shapeCurve / 2) * 2 - 1
        ) : (
          // 5 square duty
          Math.sin(t ** 3)
        ) : (
          // 4 noise
          Math.max(Math.min(Math.tan(t), 1), -1)
        ) : (
          // 3 tan
          1 - (2 * t / PI2 % 2 + 2) % 2
        ) : (
          // 2 saw
          1 - 4 * abs(Math.round(t / PI2) - t / PI2)
        ) : (
          // 1 triangle
          Math.sin(t)
        );
        s = (repeatTime ? 1 - tremolo + tremolo * Math.sin(PI2 * i / repeatTime) : 1) * (shape > 4 ? s : sign(s) * abs(s) ** shapeCurve) * // shape curve
        (i < attack ? i / attack : (
          // attack
          i < attack + decay ? (
            // decay
            1 - (i - attack) / decay * (1 - sustainVolume)
          ) : (
            // decay falloff
            i < attack + decay + sustain ? (
              // sustain
              sustainVolume
            ) : (
              // sustain volume
              i < length - delay ? (
                // release
                (length - i - delay) / release * // release falloff
                sustainVolume
              ) : (
                // release volume
                0
              )
            )
          )
        ));
        s = delay ? s / 2 + (delay > i ? 0 : (
          // delay
          (i < length - delay ? 1 : (length - i) / delay) * // release delay 
          b[i - delay | 0] / 2 / volume
        )) : s;
        if (filter)
          s = y1 = b2 * x2 + b1 * (x2 = x1) + b0 * (x1 = s) - a2 * y2 - a1 * (y2 = y1);
      }
      f = (frequency += slide += deltaSlide) * // frequency
      Math.cos(modulation * modOffset++);
      t += f + f * noise * Math.sin(i ** 5);
      if (jump && ++jump > pitchJumpTime) {
        frequency += pitchJump;
        startFrequency += pitchJump;
        jump = 0;
      }
      if (repeatTime && !(++repeat % repeatTime)) {
        frequency = startFrequency;
        slide = startSlide;
        jump || (jump = 1);
      }
    }
    return b;
  },
  // get frequency of a musical note on a diatonic scale
  getNote: function(semitoneOffset = 0, rootNoteFrequency = 440) {
    return rootNoteFrequency * 2 ** (semitoneOffset / 12);
  }
};
var ZZFXSound = class {
  constructor(zzfxSound = []) {
    this.zzfxSound = zzfxSound;
    this.randomness = zzfxSound[1] != void 0 ? zzfxSound[1] : 0.05;
    zzfxSound[1] = 0;
    this.samples = ZZFX.buildSamples(...zzfxSound);
  }
  play(volume = 1, pitch = 1, randomnessScale = 1, pan = 0, loop = false) {
    if (!this.samples) return;
    const playbackRate = pitch + pitch * this.randomness * randomnessScale * (Math.random() * 2 - 1);
    this.source = ZZFX.playSamples([this.samples], volume, playbackRate, pan, loop);
    return this.source;
  }
};
export {
  ZZFX,
  ZZFXSound,
  zzfx
};
//# sourceMappingURL=zzfx.js.map
